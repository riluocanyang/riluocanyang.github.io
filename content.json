[{"title":"作用域和闭包","date":"2017-08-10T07:20:04.000Z","path":"2017/08/10/作用域和闭包/","text":"一、作用域是什么？&emsp;&emsp;作用域是根据名称查找变量的一种规则，也就是确定当前执行代码对变量的访问权限。&emsp;&emsp;对程序“var a = 2; ”进行处理的的重要“演员表”：&emsp;&emsp;1、引擎：负责整个javascript程序的编译和执行过程。&emsp;&emsp;2、编译器（解释器）：负责语法分析及代码生成等。&emsp;&emsp;3、作用域：负责搜集并维护由所有声明的标识符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。（即负责当前执行的代码对标识符的访问权限） &emsp;&emsp;js代码在执行时由编译器（解释器）进行编译（解释） &emsp;&emsp;1、编译（解释）&emsp;&emsp;遇到var a，编译器（解释器）会询问作用域是否已有一个该名称的变量存在于当前作用域中，如果是，则忽略该声明；否则会在当前作用域下声明一个新的变量，并命名为a；&emsp;&emsp;接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2 这个操作。&emsp;&emsp;编译（解释）：声明变量和函数，把代码变成机器指令 &emsp;&emsp;2、运行&emsp;&emsp;引擎首先会问作用域，当前作用域中是否存在一个叫a的变量，如果是，引擎会将2赋值给变量a；否则，引擎会沿着作用域链查找该变量。如果找到了会将2赋值给变量a，如果没有找到则会抛出一个异常。&emsp;&emsp;引擎在查找变量a的时候，会进行LHS/RHS查询。&emsp;&emsp;LHS—赋值操作的左侧，RHS—赋值操作的右侧&emsp;&emsp;&emsp;&emsp;在非严格模式下，当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域就会创建一个具有改名称的变量，并将其返还给引擎。&emsp;&emsp;如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferrenceError异常。如果RHS查询到了一个变量，但是对这个变量进行了不合理的操作，若引用undefined或者null的属性，则会抛出TypeError异常。（注：ReferenceError同作用域判别失败有关，TypeError代表作用域判别成功了，但是进行了不合理、非法的操作。）&emsp;&emsp;在严格模式下，禁止自动或隐式的创建全局变量，LHS查询失败时，并不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的ReferenceError异常。&emsp;&emsp;（运行：执行机器指令，查询变量，并进行一些操作） 二、词法作用域&emsp;&emsp;作用域主要有两种模型：词法作用域（静态作用域）和动态作用域。js采用的是词法作用域。&emsp;&emsp;词法作用域是在函数定义时的环境中查找，动态作用域是在函数运行时的环境中查找。即词法作用域是定义时确定的，动态作用域是运行时确定的。 三、函数作用域&emsp;&emsp;函数作用域就是定义在函数中的变量和参数在函数外部不可见。js没有块级作用域。&emsp;&emsp;JS并不支持块级作用域，它只支持函数作用域，而且在一个函数中的任何位置定义的变量在该函数中的任何地方都是可见的。 四、提升&emsp;&emsp;只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。函数表达式也不会被提升。&emsp;&emsp;每个作用域都会进行提升操作。 &emsp;&emsp;函数声明会提升&emsp;&emsp; &emsp;&emsp;函数表达式不会提升&emsp;&emsp;&emsp;&emsp;即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。&emsp;&emsp; &emsp;&emsp;函数优先&emsp;&emsp;函数声明和变量声明都会被提升，但是是函数首先被提升，然后才是变量。&emsp;&emsp;&emsp;&emsp;函数提升后，var foo是重复的声明，var foo会被忽略掉。 五、闭包&emsp;&emsp;当函数可以记住并访问所在的词法作用域，即使函数是在当前作用域之外执行，这时就产生了闭包。&emsp;&emsp;当一个函数返回它内部的一个函数时，就产生了闭包。如：&emsp;&emsp;&emsp;&emsp;Js特殊之处：可以在函数内部读取全局变量，但是不能再函数外部读取函数内部的局部变量。由于种种原因，我们需要在函数外面获取函数内部的局部变量，通过闭包的方法可以实现。即在函数内部在定义一个函数。&emsp;&emsp;闭包就是能访问另一个函数作用域中的变量的函数。创建闭包的方式，就是在一个函数内部创建另一个函数。本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 &emsp;&emsp;闭包的优点&emsp;&emsp;1、可以在函数外部读取函数内部的变量。&emsp;&emsp;2、可以将变量保存在内存中，避免使用全局对象。&emsp;&emsp;3、封装对象的私有属性和方法。&emsp;&emsp;4、在循环中使用。 &emsp;&emsp;闭包的缺点&emsp;&emsp;1、由于闭包都保存在内存中，使得内存消耗很大，不能滥用闭包。&emsp;&emsp;2、由于回收机制问题，可能导致内存泄露。解决办法，程序退出前，将不用的变量设置为null。&emsp;&emsp;3、增加了代码的复杂度，给维护和调试带来了不变。 【参考文章】1、了不起的node.js2、深入理解javascript作用域系列第二篇——词法作用域和动态作用域3、JavaScript的作用域和块级作用域概念理解","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"操作符","date":"2017-08-09T01:20:02.000Z","path":"2017/08/09/操作符/","text":"相等（==）操作符&emsp;&emsp;相等操作符的最终结果是将其他非数值类型转化为数值类型。相等操作符转换规则如下：&emsp;&emsp;&emsp;&emsp;左右两边类型相等：&emsp;&emsp;1、NaN != NaN &emsp;&emsp; -0 == +0&emsp;&emsp;2、两边都是对象比较的是地址&emsp;&emsp;左右两边类型不相等：&emsp;&emsp;1、undefined == null&emsp;&emsp;2、有 null/undefined 参与的 == 运算是不进行隐式转换。&emsp;&emsp;&emsp;&emsp;0 == null; // false&emsp;&emsp;&emsp;&emsp;null == false; // false&emsp;&emsp;&emsp;&emsp;”undefined” == undefined; // false&emsp;&emsp;3、一个是number，一个是string，string将调用toNumber()转换为number&emsp;&emsp;4、一个是boolean，一个是number，boolean将调用toNumber()转换为number&emsp;&emsp;5、一个是boolean，一个是string，boolean和String将调用toNumber()转换为number&emsp;&emsp;6、一个是object，另一个是其他（string/number),object将调用toPrimitive() &emsp;&emsp;toNumber方法即Number转换规则：&emsp;&emsp; &emsp;&emsp;toPrimitive方法如下：&emsp;&emsp;&emsp;&emsp;原始值指的是[‘Null’,’Undefined’,’String’,’Boolean’,’Number’]五种基本数据类型之一 &emsp;&emsp;valueOf返回值：&emsp;&emsp;注意：Number、Boolean、String有属于自身的原型valueOf方法，不是直接从Object.prototype上继承下来，归纳如下：&emsp;&emsp; &emsp;&emsp;toString返回值：&emsp;&emsp; &emsp;&emsp;==总结&emsp;&emsp; 一元加操作符&emsp;&emsp;var num = 25；&emsp;&emsp;num = +num;&emsp;&emsp;改操作符会像Number（）函数一样对非数值类型进行转换。 布尔操作符&emsp;&emsp;操作符转换规则：&emsp;&emsp; &emsp;&emsp;! 取反&emsp;&emsp;!x 将表达式x转换成布尔值（Boolean），之后在将结果取反。&emsp;&emsp;!!x 则表示取 x 表达式的运行结果的布尔值。&emsp;&emsp;&emsp;&emsp;var obj = {};&emsp;&emsp;&emsp;&emsp;var a = !obj // false;&emsp;&emsp;&emsp;&emsp;var a = !!obj // true; &emsp;&emsp;&amp;&amp; 逻辑与&emsp;&emsp;x &amp;&amp; y 如果 x 表达式的运行结果转换成 Boolean 值为 false 则不运行表达式 y 而直接返回 x 表达式的运行结果。相反，如果 x 表达式的运行结果转换成 Boolean 值为 true 则运行表达式 y 并返回 y 表达式的运行结果。 &emsp;&emsp;|| 逻辑或&emsp;&emsp;x || y 如果 x 表达式的运行结果转换为 Boolean 值为 true，则不运行 表达式 y 而直接返回表达式 x 的运算结果。（与 &amp;&amp; 方式相反） 【参考文章】1、从 []==![] 为 true 来剖析 JavaScript 各种蛋疼的类型转换2、toString 方法 (Object) (JavaScript)3、valueOf 方法 (Object) (JavaScript)4、表达式与运算符","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript基础----引用类型","date":"2017-08-07T01:20:15.000Z","path":"2017/08/07/javascript基础---引用类型/","text":"&emsp;&emsp;javascript 类型系统可以分为标准类型和对象类型，进一步标准类型又可以分为原始类型和引用类型，而对象类型又可以分为内置对象类型、普通对象类型、自定义对象类型。&emsp;&emsp; 标准内置对象构造器对象ObjectBooleanStringNumberFunctionArrayRegExpDateError其他对象 MathJSON全局对象 类型识别&emsp;&emsp;typeof&emsp;&emsp;Object.prototype.toString&emsp;&emsp;constructor&emsp;&emsp;instanceof &emsp;&emsp;typeof：&emsp;&emsp;可以是标准类型（Null 除外）&emsp;&emsp;不可识别具体的对象类型（Function 除外） &emsp;&emsp;Object.prototype.toString：&emsp;&emsp;可以识别标准类型&emsp;&emsp;可是识别标准类型及内置对象类型（例如，Object, Date, Array）&emsp;&emsp;不能识别自定义对象类型 &emsp;&emsp;constructor：&emsp;&emsp;可以识别标准类型（Undefined/Null 除外）&emsp;&emsp;可识别内置对象类型&emsp;&emsp;可识别自定义对象类型 &emsp;&emsp;instanceof：&emsp;&emsp;不可判别原始类型&emsp;&emsp;可判别内置对象类型&emsp;&emsp;可判别自定义对象类型&emsp;&emsp;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript基础---基本数据类型","date":"2017-08-04T14:11:50.000Z","path":"2017/08/04/javascript基础---基本数据类型/","text":"一、Javascript简介&emsp;&emsp; 在上个世纪1995年，Netscape公司凭借其Navigator浏览器成为第一代互联网公司。之后，Netscape公司希望能在静态HTML页面上添加一些动态效果，于是Brendan Eich在两周之内设计出了JavaScript语言。由于当时java很火，Netscape公司希望借java热风推广，便取名为javascript。&emsp;&emsp; 之后，微软模仿javascript开发了Jscript，此时，相当于有了两个JavaScript版本。为了让Javascript成为国际标准，几个公司联合ECMA组织制订了Javascript语言的标准，被称为ECMAScript标准。&emsp;&emsp; ECMA就是对标准规定的各个方面内容的语言的描述，可以理解为ECMA仅仅是一个描述，定义了脚本语言的所有属性、方法和对象。其他的语言可以实现ECMAScript，来作为功能的基准，javascript就是这样。&emsp;&emsp; web浏览器只是ECMAScript实现可能的宿舍环境之一，宿主环境不仅提供基本的ECMAScript实现，同时也会提供语言的扩展。可以理解为每个浏览器都有自己的ECMAScript接口，然后这个实现又被扩展，包含了BOM和DOM以及其他扩展。&emsp;&emsp;一个完整的javascript实现应该由下列三个不同的部分组成：&emsp;&emsp;● ECMAScript（核心） ECMAScript描述了该语言的语法和基本对象；&emsp;&emsp;● DOM（文档对象模型）DOM 描述了处理网页内容的方法和接口；&emsp;&emsp;● BOM（浏览器对象模型）BOM描述了与浏览器进行交互的方法和接口。 二、Javascript数据类型&emsp;&emsp;ECMAScript中有6种简单数据结构（基本数据类型）：Undefined、Null、Boolean、Number、String、Symbol。还有一种复杂结构类型（引用类型）Object。&emsp;&emsp;基本数据类型保存在内存的栈区，复制变量时会创建其值的一个副本。基本数据类型可以使用typeof区分。&emsp;&emsp;引用类型的存储是由内存的栈区和堆区共同完成，引用类型的值是对象,保存在堆内存中，栈区内存保存变量标识符和指向堆内存中该对象的指针，也就是该对象在堆内存的地址。 1、Undefined类型&emsp;&emsp;使用var声明但是未初始化的变量其值为undefined。使用未声明的变量会报错。如：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;但是，对未初始化的变量执行typeof操作符会返回undefined值，对未声明的变量执行typeof操作符也会返回undefined。&emsp;&emsp;&emsp;&emsp; 2、Null类型&emsp;&emsp;如果定义的变量将来准备用于保存变量，那么最好将该变量初始化为null。 &emsp;&emsp;null和undefined的区别&emsp;&emsp;undefined派生自null，用相等操作符(==)它们是相等的。&emsp;&emsp;&emsp;&emsp;在if语句中，null和undefined都会被转换为false。但是，它们都不等于0，false或””&emsp;&emsp;&emsp;&emsp;null转为数值时值为0,undefined转为数值时值为NaN.&emsp;&emsp;typeof null 返回object, typeof undefined 返回undefined.&emsp;&emsp;&emsp;&emsp;undefined表示“不存在的值”，应用场景:&emsp;&emsp;1、变量声明了，但是没有赋值，会有一个undefined的默认值；&emsp;&emsp;2、调用函数时，函数没有赋值的参数，默认为undefined；&emsp;&emsp;3、试图访问不存在的对象属性时，会返回undefined值；&emsp;&emsp;4、函数没有返回值，默认返回undefined。&emsp;&emsp;null表示“没有对象”，应用场景：&emsp;&emsp;1、作为函数的参数，表示该函数的参数不是对象；&emsp;&emsp;2、作为原型对象链的终点；&emsp;&emsp;3、通过分配null值，有效的清除引用，并假设对象没有引用其他代码，指定垃圾回收，确保回收内存。&emsp;&emsp;在ES5中，Object.prototype.toString()方法，已经成为实际的类型检验标准。 3、Boolean类型&emsp;&emsp;Boolean类型有两个值:true和false。&emsp;&emsp;要将一个值转换为Boolean值，可以调用转型函数Boolean()。各种数据类型极其对应的转换规则：&emsp;&emsp; 4、Number类型&emsp;&emsp;数值字面量可以是十进制整数，八进制整数，十六进制整数。其中八进制字面量的第一位必须是零（0），数字序列为（0-7）；十六进制字面量的前两位必须是0x，数字序列（0-9及A-F），字母可大写可小写，超出范围报错。 &emsp;&emsp;（1）数值范围&emsp;&emsp;Number.MAX_VALUE 最大数值&emsp;&emsp;Number.MAX_VALUE 最小数值，代表的并不是负最小，而是最接近0的一个数&emsp;&emsp;-Number.MAX_VALUE 负最小 &emsp;&emsp;（2）NaN&emsp;&emsp;任何数除以0都会返回NaN，其次，NaN与任何值都不相等，包括NaN本身。 &emsp;&emsp;（3）数值转换&emsp;&emsp;有3个函数可以把非数值转换为数组，Number()、parseInt()、parseFloat()。&emsp;&emsp;Number()可以用于任何数据类型，而另外两个专门用于把字符串转换为数组。 &emsp;&emsp;Number函数转换规则&emsp;&emsp;如果是Boolean值，true和false将分别被转换为1和0。&emsp;&emsp;如果是数字值，只是简单的传入和返回。&emsp;&emsp;如果是undefined，返回NaN。&emsp;&emsp;如果是null，返回0。&emsp;&emsp;如果是字符串，&emsp;&emsp;&emsp;&emsp;若只包含数字，则将其转化为十进制数值。如”1”-&gt;1，”123”-&gt;123，而”011”-&gt;11。&emsp;&emsp;&emsp;&emsp;如果字符串包含有效的十六进制格式，如”0xf”，则将其转化为相同大小的十进制。&emsp;&emsp;&emsp;&emsp;如果字符串包含有效的浮点格式，如”1.1”，则将其转化为对应的浮点数值。&emsp;&emsp;&emsp;&emsp;如果字符串是空的或者只包含空格字符串，则将其转化为0。&emsp;&emsp;如果是对象，则调用对象的valueOf()方法，然后按照前面的规则转换。如果转换的结果是NaN，则调用对象的toString()方法，然后按照前面的规则转换。 &emsp;&emsp;parseInt函数转换规则—针对字符串&emsp;&emsp;parseInt（）函数在转换字符串时，会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt（）就会返回NaN，即parseInt会将空的字符串转化为NaN。&emsp;&emsp;parseInt可以指定基数，如：&emsp;&emsp;var num1 = parseInt(“10”,2);&emsp;&emsp;var num1 = parseInt(“10”,10);&emsp;&emsp;var num1 = parseInt(“10”,16); &emsp;&emsp;parseFloat函数转换规则—针对字符串&emsp;&emsp;parseFloat（）函数与parseInt类似，解析遇到一个无效的浮点数字字符为止。也就是说，第一个小数点有效，第二个小数点无效。&emsp;&emsp;注意：parseFloat在解析十六进制的字符串时，会始终将其转换为0。parseFloat只解析十进制，没有第二个参数（基数）的用法。 5、String类型&emsp;&emsp;字符串可以由单引号’’或者双引号””表示。字符串是不可变的，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，如：&emsp;&emsp;var lang = “Java”;&emsp;&emsp;lang = lang + “Script”;&emsp;&emsp;首先创建一个能容纳10个字符的新字符串，然后在这个字符串中填充”Java”和”Script”,最后是销毁原来的字符串”Java”和字符串”Script”。 &emsp;&emsp;转换为字符串&emsp;&emsp;第一种是几乎每个值都有的toString()方法，但null和undefined值没有这个方法。&emsp;&emsp;第二种：在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String(),这个函数能将任何类型的值转换为字符串。转换规则如下：&emsp;&emsp;如果有toString()方法，则调用并返回相应的结果；&emsp;&emsp;如果值是null，则返回”null’；&emsp;&emsp;如果值是undefined，则返回’undefined’； 6、Symbol类型&emsp;&emsp;symbol是程序创建并且可以用作属性键的值，并且它能避免命名冲突的风险。&emsp;&emsp;var mySymbol = Symbol();&emsp;&emsp;obj[mySymbol] = “ok!”; // 保证不会冲突&emsp;&emsp;console.log(obj[mySymbol]); // ok!&emsp;&emsp;symbol被创建后就不可变更，你不能为它设置属性（在严格模式下尝试设置属性会得到TypeError的错误）。他们可以用作属性名称，这些性质与字符串类似。&emsp;&emsp;另一方面，每一个symbol都独一无二，不与其它symbol等同，即使二者有相同的描述也不相等；你可以轻松地创建一个新的symbol。这些性质与对象类似。 6、Object类型对象其实就是一组数据和功能的集合。引用类型下一篇文章总结。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"认识vue.js","date":"2017-07-28T07:45:17.000Z","path":"2017/07/28/认识vue.js/","text":"我们首先了解一下MVX模式MVX模式：MVC、MVP、MVVM MVCMVC一般分为Model（模型）、View（视图）和Controller（控制器）。 View一般通过Controller来和View进行联系。Controller是View和Model的协调者。基本联系都是单向的。1.View传送指令到Controller2.Controll接收指令处理后，要求Model改变状态3.Model将新的数据传送给View。 MVPMVP一般分为Model（模型）、View（视图）和Presenter。Presenter把View和Model进行了分离，而且，Presenter与具体的View没有直接联系，是通过定义好的接口进行联系的。 MVVMMVVM分为Model（模型）、View（视图）和ViewModel。View的变化会自动更新到ViewModel，viewModel的变化也会同步到View上。MVVM采用双向绑定（data-binding）","tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://yoursite.com/tags/vue-js/"},{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"}]},{"title":"Hello World","date":"2017-02-27T03:08:12.227Z","path":"2017/02/27/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]