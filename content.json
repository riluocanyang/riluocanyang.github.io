[{"title":"原型及原型链","date":"2017-08-18T07:34:36.000Z","path":"2017/08/18/原型及原型链/","text":"","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"正则表达式","date":"2017-08-16T07:51:58.000Z","path":"2017/08/16/正则表达式/","text":"","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"算法--排序","date":"2017-08-15T02:24:31.000Z","path":"2017/08/15/算法-排序/","text":"&emsp;&emsp;选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，&emsp;&emsp;冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。 1、插入排序算法/* 插入排序,在前K个元素有序排列的情况下，将第K+1个元素与前K个元素比较， 最终将第K+1个元素插入到合适的位置，使这K+1个元素保持有序。 时间复杂度O(n^2) */ function insertSort(arr){ for(let i = 1,len = arr.length; i&lt;len; i++){ let temp = arr[i]; for(let j = i; j&gt;0; --j){ if(arr[j-1]&gt;temp){ arr[j] = arr[j-1]; }else{ arr[j] = temp; break; } } } return arr; } /*简化代码*/ function insertSort(arr){ for(let i = 1,len = arr.length; i&lt;len; i++){ let temp = arr[i]; let j = i; for(; j&gt;0 &amp;&amp; arr[j-1]&gt;temp; --j){ arr[j] = arr[j-1]; } arr[j] = temp; } return arr; } &emsp;&emsp;时间复杂度O(n^2)&emsp;&emsp;注意：如果没有返回值，函数默认返回undefined。这应该与java不同。 2、简单选择算法/* 简单选择排序，每次遍历选出最小的min并与相应位置交换（第一次遍历 同第一个元素交换，依次类推），每次遍历可找出最小值或最大值。 时间复杂度O(n^2) */ function selectSort(arr){ let len = arr.length, temp; for(let i=0; i&lt;len-1; i++){ let minIndex = i; for(let j=i+1; j&lt;len; ++j){ if(arr[minIndex]&gt;arr[j]){ minIndex = j; } } temp = arr[minIndex]; arr[minIndex] = arr[i]; arr[i] = temp; } return arr; } &emsp;&emsp;时间复杂度O(n^2) 3、冒泡排序算法/* 冒泡排序，与相邻元素比较大小并交换，每一轮会找出最大值或者最小值。 时间复杂度O(n^2) */ function bubbleSort(arr){ let len = arr.length, temp; for(let i=len-1;i&gt;0;--i){ for(let j=0;j&lt;i;j++){ if(arr[j]&gt;arr[j+1]){ temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } return arr; } &emsp;&emsp;时间复杂度O(n^2) 4、归并算法/* 归并排序将元素平均划分为2组，再将每组元素继续平均划分为2组，直到不能划分。 归并排序先划分，在合并。 时间复杂度O(nlogn) */ function mergeSort(arr){ if(arr.length &lt; 2){ return arr; } let mid = parseInt(arr.length/2); let left = arr.slice(0,mid); let right = arr.slice(mid); return merge(mergeSort(left),mergeSort(right)); } function merge(left,right){ let temp = []; while(left.length &amp;&amp; right.length){ if(left[0]&lt;right[0]){ temp.push(left.shift()); }else{ temp.push(right.shift()); } } return temp.concat(left,right); } &emsp;&emsp;时间复杂度O(nlogn)&emsp;&emsp;但是mergeSort()函数会导致很频繁的自调用。一个长度为n的数组最终会调用mergeSort() 2*n-1次，这意味着如果需要排序的数组长度很大会在某些栈小的浏览器上发生栈溢出错误。 /* 改进方法*/ function mergeSort(arr){ if(arr.length === 1){ return arr; } let newArr = [], len = arr.length; for(let i=0;i&lt;len;i++){ //例如：newArr=[[1],[2],[3],[4],[5],[6]] //newArr中的每一个元素都是数组 newArr.push([arr[i]]); } if(newArr.length%2 !== 0){ newArr.push([]); //保证arrLen是偶数 } var arrLen = newArr.length; for(let i=arrLen;i&gt;1;i=i/2){ for(var j=0,k=0;j&lt;i;j+=2,k++){ newArr[k] = merge(newArr[j],newArr[j+1]); } if(k%2!==0){ newArr[k] = []; } } return newArr[0]; } function merge(left,right){ //left,right均为数组 let temp = []; while(left.length &amp;&amp; right.length){ if(left[0] &lt; right[0]){ temp.push(left.shift()); }else{ temp.push(right.shift()); } } return temp.concat(left,right); } 5、快速排序算法/* 1、在数据集之中，选择一个元素作为&quot;基准&quot;（pivot） 2、所有小于&quot;基准&quot;的元素，都移到&quot;基准&quot;的左边；所有大于&quot;基准&quot;的元素，都移到&quot;基准&quot;的右边。 3、对&quot;基准&quot;左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 */ /*方法一：容易理解，占用内存大*/ function quickSort(arr){ if(arr.length &lt;= 1 ){ //arr.length&lt;=1不是===1，否则，报错，栈溢出。 //因为left或者right可能为空。 return arr; } let pivotIndex = Math.floor(arr.length/2), //“基准” pivot = arr.splice(pivotIndex,1)[0],//splice返回被删除元素组成的数组,同时原数组被改变。 left = [], right = []; for(let i=0;i&lt;arr.length;i++){ if(arr[i]&lt;pivot){ left.push(arr[i]); }else if(arr[i]&gt;pivot){ right.push(arr[i]); } } return quickSort(left).concat([pivot],quickSort(right)); } /*方法二：快速排序思想*/ /* 每次都以left作为“基准”，并且能够确定其在数组中的位置。 根据left的位置，将数组分为两部分，对着两部分继续采用上述方法。 */ function quickSort(arr,left,right){ var left = typeof left !==&apos;number&apos;?0:left; var right = typeof right !==&apos;number&apos;?arr.length-1:right; if(left &gt;= right){ return; } if(left&lt;right){ let midIndex = quick(arr,left,right); quickSort(arr,left,midIndex - 1); quickSort(arr,midIndex + 1,right); } return arr; } function quick(arr,left,right){ let temp = arr[left]; while(left &lt; right){ for(;left&lt;right &amp;&amp; arr[right]&gt;=temp;right--){ } if(left&lt;right){ arr[left++] = arr[right]; } for(;left&lt;right &amp;&amp; arr[left]&lt; temp;left++){ } if(left&lt;right){ arr[right--] = arr[left]; } } arr[left] = temp; return left; } 6、二分查找算法/* 二分查找算法比较的前提是数组是一个有序数组，采用折中的方法查找 */ function binarySearch(arr,target){ let left = 0; let right = arr.length-1; while(left&lt;=right){ let middle = (left+right)/2; let midValue = arr[middle]; if(midValue &gt; target){ right = middle - 1; }else if(midValue &lt; target){ left = middle + 1; }else{ return middle; } } return -1; } &emsp;&emsp; 【参考文章】1、数据结构与算法-算法基础二2、【前端也要学点算法】 归并排序的JavaScript实现3、JS实现快速排序算法的详细解释4、快速排序（Quicksort）的Javascript实现5、常用排序算法稳定性、时间复杂度分析（转，有改动）","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"js引擎","date":"2017-08-14T10:01:26.000Z","path":"2017/08/14/js引擎/","text":"&emsp;&emsp;javascript是一种解释型语言，不需要编译，边执行边解析。编译型语言是在执行之前将源代码编译成目标代码，不需要解释器，直接在目标代码的平台上运行。 一、js引擎的作用和优缺点&emsp;&emsp;作用&emsp;&emsp;javascript引擎的主要作用是读取网页中的javascript代码，对其处理后运行。 &emsp;&emsp;优缺点&emsp;&emsp;优点：运行和修改方便，刷新页面重新解释。&emsp;&emsp;缺点：每次运行都需要运行解释器，系统开销大，运行速度慢于编译型语言。&emsp;&emsp;由于javascript是在前端运行的，需要即时响应用户的需求，这就要求js能够快速的解析和执行。 二、js引擎解释器&emsp;&emsp;javascript引擎通常包含4个组成部分：&emsp;&emsp;● 词法分析器（Lexical Analyser）&emsp;&emsp;● 语法分析器（Syntax Parser）&emsp;&emsp;● 字节码生成器（Bytecode generator）&emsp;&emsp;● 字节码解释器（Bytecode interpreter） &emsp;&emsp;1、词法分析器读取源代码，将代码一行行进行词法分析，即将代码解析成“词元”； &emsp;&emsp;2、语法分析器对词元进行语法分析，按照一定规则，解析成抽象语法生成树(Syntax tree),如果有语法错误，则报错。例如：将this赋值（var this = {}），少些括号等。这个阶段仅仅是解析语法。 &emsp;&emsp;3、字节码生成器通过“翻译器”，将字节码转换为字节码。 &emsp;&emsp;3、字节码解释器&emsp;&emsp;3将字节码转换为机器码。&emsp;&emsp;3逐行将字节码转换为机器码，是很耗时的，为了提高效率，引入了“即时编译”（JIT）。谷歌浏览器直接将源代码编译为机器码。&emsp;&emsp;3现在JavaScript引擎的执行过程大致是：&emsp;&emsp;3源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎没有中间字节码)。&emsp;&emsp;（在 V8 的 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译，此后 V8 将与 JavaScriptCore 有大致相同的流程。） 【参考文章】1、浏览器环境概述2、认识 V8 引擎","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"this解析","date":"2017-08-14T06:55:27.000Z","path":"2017/08/14/this解析/","text":"一、默认绑定&emsp;&emsp;最常用的函数调用类型：独立函数调用。&emsp;&emsp;非严格模式下：this—&gt; window；&emsp;&emsp;&emsp;&emsp;函数调用时，应用了this的默认绑定，因此this指向全局对象。 二、隐式绑定&emsp;&emsp;这个规则需要考虑的是调用位置是否有上下文对象，或者说是否被某个对象“拥有”或者“包含”。&emsp;&emsp;在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this隐式绑定到这个对象上。&emsp;&emsp;&emsp;&emsp;但是，无论直接在obj中定义还是先定义在添加为引用属性，这个函数严格来说都不属于obj对象。 &emsp;&emsp;对象属性引用链中只有最顶层或者说最后一层会影响调用位置。例如：&emsp;&emsp; &emsp;&emsp;this隐式绑定问题 ：&emsp;&emsp;1、一个最常见的this绑定问题就是隐式绑定的函数会丢失绑定对象。也就是他会应用默认绑定。&emsp;&emsp; &emsp;&emsp;2、还有一种情况是发生在传入回调函数时：&emsp;&emsp;将函数的引用作为参数传入另一个函数，也会应用默认绑定。&emsp;&emsp; 三、new绑定&emsp;&emsp;在js中，构造函数只是一些使用new操作符时被调用的函数。&emsp;&emsp;使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：&emsp;&emsp;1、创建（或者说构造）一个全新的对象&emsp;&emsp;2、这个新对象会被执行[[原型]]连接&emsp;&emsp;3、这个新对象会绑定到函数调用的this （this指向这个对象）&emsp;&emsp;4、如果函数没有其他返回对象，那么new表达式中的函数调用会自动返回这个新对象。 四、显示绑定&emsp;&emsp;使用函数的call（）和apply（）方法。它们的第一个参数是一个对象，它们会把这个对象绑定到this，接着在调用函数时指定这个this。因为可以直接指定this的绑定对象，所以称之为显示绑定。&emsp;&emsp;&emsp;&emsp;如果传入了一个原始值（字符串类型、数值类型、布尔类型）来当作this的绑定对象，这个原始值会被转换为它的对象形式（new String（）、new Number（）、new Boolean（）），通常称为“装箱”。解决绑定丢失方法（如闭包中子函数this丢失）： &emsp;&emsp;call和apply方法&emsp;&emsp;直接使用call和apply方法。&emsp;&emsp;call方法：&emsp;&emsp;&emsp;&emsp;apply方法：&emsp;&emsp; &emsp;&emsp;bind方法&emsp;&emsp;&emsp;&emsp;由于bind绑定是一种非常常用的模式，在ES5中提供了内置的方法Function.prototype.bind,它的用法如下：&emsp;&emsp; 五、优先级&emsp;&emsp;New绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 六、判断this&emsp;&emsp;函数是否是在new中调用（new绑定）？如果是，this绑定的是新创建的对象&emsp;&emsp;var bar = new foo() &emsp;&emsp;函数是否通过call、apply（显示绑定）？如果是，this绑定的是指定的对象&emsp;&emsp;var bar = foo.call(obj) &emsp;&emsp;函数是否在某个上下文对象中调用（隐式绑定）？如果是，this绑定的是那个上下文对象&emsp;&emsp;var bar =obj.foo() &emsp;&emsp;如果都不是，使用默认绑定。&emsp;&emsp;var bar = foo()&emsp;&emsp;严格模式下默认绑定的this值为undefined，其值不会转换为window，而在非严格模式下则会转化为window。另外，全局模式下的this指向window，不属于默认绑定。严格模式除了默认绑定，其他规则都适应。例如： &quot;use strict&quot;; //全局对象 ---window console.log(this); //new ---new出来的对象 function Animal(){ console.log(this); } let animal = new Animal(); //obj.foo() --- obj function fun(){ console.log(this); //console.log(this.a); //2 } var obj = { a:2, fun:fun } obj.fun(); //foo --- undefined，默认绑定失效 function foo(){ console.log(this); } foo(); 七、绑定例外&emsp;&emsp;1、被忽略的this&emsp;&emsp;如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际上应用的是默认绑定。&emsp;&emsp;foo.call(null); &emsp;&emsp;2、间接引用&emsp;&emsp;间接引用最容易发生在赋值时。创建函数的间接引用，调用这个函数会应用默认绑定。&emsp;&emsp; &emsp;&emsp;3、箭头函数&emsp;&emsp;箭头函数不使用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this。&emsp;&emsp;&emsp;&emsp;如果将箭头函数改为一般函数&emsp;&emsp; 八、this其他应用&emsp;&emsp;1、DOM 事件回调中的this&emsp;&emsp;this绑定的是绑定该事件的DOM元素。 &emsp;&emsp;2、HTML中的this&emsp;&emsp;this指代该HTML元素。 &emsp;&emsp;3、无法重写this&emsp;&emsp;无法重写this，因为它是一个关键字。&emsp;&emsp; &emsp;&emsp;4、数组forEach中的this&emsp;&emsp;如果给forEach传递了thisArg参数，当调用时，它将被传给callback 函数，作为它的this值。否则，将会传入 undefined 作为它的this值。&emsp;&emsp;&emsp;&emsp;注意：如果使用箭头函数表达式传入函数参数，thisArg 参数会被忽略，因为箭头&emsp;&emsp;函数在词法上绑定了this值。 &emsp;&emsp;对象复制函数&emsp;&emsp;下面的代码会创建一个给定对象的副本。&emsp;&emsp; 【参考文章】1、了不起的javascript2、详解this","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"执行上下文","date":"2017-08-11T00:32:37.000Z","path":"2017/08/11/执行上下文/","text":"一、可执行代码&emsp;&emsp;ES可执行代码（executable code）分为3种：&emsp;&emsp;&emsp;全局代码—javascript代码首次进入的环境&emsp;&emsp;&emsp;函数代码—函数被调用时，进入函数执行环境&emsp;&emsp;&emsp;eval代码 二、可执行上下文&emsp;&emsp;当控制器转到可执行代码时，会进入一个执行上下文（Execution Content，EC）。进入全局代码时，会创建全局环境执行上下文；调用函数时，会创建函数执行上下文。处于活动状态的执行上下文环境只会有一个。&emsp;&emsp;JS引擎创建了执行上下文栈（Execution Content Stack，ECS）管理执行上下文。每个执行上下文都有3个重要属性：&emsp;&emsp;● 变量对象（Variable Object,VO）&emsp;&emsp;● 作用域链（Scope Chain）&emsp;&emsp;● this &emsp;&emsp;1、变量对象&emsp;&emsp;变量对象是与执行上下文相关的数据作用域，存储了函数的参数、变量和函数声明。它是一个抽象的概念。&emsp;&emsp;当进入执行上下文时，VO的初始化过程如下:&emsp;&emsp;函数的形参（如果是函数上下文）— 变量对象的属性：&emsp;&emsp;由属性名和值组成的键值对，属性名就是形参的名称，属性值就是形参的值。如果没有实参，其值为undefined。&emsp;&emsp;函数声明 — 变量对象的属性：&emsp;&emsp;由属性名和值组成的键值对，属性名就是函数的名称，属性值就是函数对象。如果变量对象已经存在相同的名称的属性，替换这个属性。&emsp;&emsp;变量声明 — 变量对象的属性：&emsp;&emsp;由属性名和值组成的键值对，属性名就是变量的名称，属性值为undefined。如果变量名和已声明的函数或者函数的参数名相同，变量声明不会影响已存在的属性。&emsp;&emsp;注意：初始化阶段变量并没有执行赋值语句。 &emsp;&emsp;全局上下文的变量对象&emsp;&emsp;在javascript中，可以用关键字this引用全局对象。在全局上下文中，变量对象也是全局对象自身。 &emsp;&emsp;函数上下文的变量对象&emsp;&emsp;函数被激活时，用活动对象（Activation Object）表示变量对象。活动对象是在进入函数上下文时被创建的，它通过函数的arguments属性初始化。arguments属性值是Arguments对象。 &emsp;&emsp;2、作用域链&emsp;&emsp;由多个执行上下文的变量对象构成的链表叫作用域链。 &emsp;&emsp;函数创建和执行过程&emsp;&emsp;在一个函数定义的时候，会保存所有父变量对象（父作用域链）到函数的[scope]属性（每个函数有一个内部属性[scope]）。 &emsp;&emsp;调用函数，创建函数执行上下文，函数执行上下文被压入执行上下文栈。 &emsp;&emsp;函数不立刻执行，开始准备工作，首先将函数上下文中的作用域链连接到函数[scope]属性，接着用arguments创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明，最后，将活动对象压入上下文的作用域链顶端。 &emsp;&emsp;准备工作做完，开始执行函数，随着函数的执行，修改AO的属性值。 &emsp;&emsp;找到变量，返回后函数执行完毕，函数上下文从执行上下文栈中弹出。 &emsp;&emsp;3、this【参考文献】1、了解JavaScript的执行上下文2、JavaScript深入之执行上下文栈3、深入理解JavaScript执行上下文、函数堆栈、提升的概念4、理解执行环境与作用域链","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"作用域和闭包","date":"2017-08-10T07:20:04.000Z","path":"2017/08/10/作用域和闭包/","text":"一、作用域是什么？&emsp;&emsp;作用域是根据名称查找变量的一种规则，也就是确定当前执行代码对变量的访问权限。&emsp;&emsp;对程序“var a = 2; ”进行处理的的重要“演员表”：&emsp;&emsp;1、引擎：负责整个javascript程序的编译和执行过程。&emsp;&emsp;2、编译器（解释器）：负责语法分析及代码生成等。&emsp;&emsp;3、作用域：负责搜集并维护由所有声明的标识符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。（即负责当前执行的代码对标识符的访问权限） &emsp;&emsp;js代码在执行时由编译器（解释器）进行编译（解释） &emsp;&emsp;1、编译（解释）&emsp;&emsp;遇到var a，编译器（解释器）会询问作用域是否已有一个该名称的变量存在于当前作用域中，如果是，则忽略该声明；否则会在当前作用域下声明一个新的变量，并命名为a；&emsp;&emsp;接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2 这个操作。&emsp;&emsp;编译（解释）：声明变量和函数，把代码变成机器指令 &emsp;&emsp;2、运行&emsp;&emsp;引擎首先会问作用域，当前作用域中是否存在一个叫a的变量，如果是，引擎会将2赋值给变量a；否则，引擎会沿着作用域链查找该变量。如果找到了会将2赋值给变量a，如果没有找到则会抛出一个异常。&emsp;&emsp;引擎在查找变量a的时候，会进行LHS/RHS查询。&emsp;&emsp;LHS—赋值操作的左侧，RHS—赋值操作的右侧&emsp;&emsp;&emsp;&emsp;在非严格模式下，当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域就会创建一个具有改名称的变量，并将其返还给引擎。&emsp;&emsp;如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferrenceError异常。如果RHS查询到了一个变量，但是对这个变量进行了不合理的操作，若引用undefined或者null的属性，则会抛出TypeError异常。（注：ReferenceError同作用域判别失败有关，TypeError代表作用域判别成功了，但是进行了不合理、非法的操作。）&emsp;&emsp;在严格模式下，禁止自动或隐式的创建全局变量，LHS查询失败时，并不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的ReferenceError异常。&emsp;&emsp;（运行：执行机器指令，查询变量，并进行一些操作） 二、词法作用域&emsp;&emsp;作用域主要有两种模型：词法作用域（静态作用域）和动态作用域。js采用的是词法作用域。&emsp;&emsp;词法作用域是在函数定义时的环境中查找，动态作用域是在函数运行时的环境中查找。即词法作用域是定义时确定的，动态作用域是运行时确定的。 三、函数作用域&emsp;&emsp;函数作用域就是定义在函数中的变量和参数在函数外部不可见。js没有块级作用域。&emsp;&emsp;JS并不支持块级作用域，它只支持函数作用域，而且在一个函数中的任何位置定义的变量在该函数中的任何地方都是可见的。 四、提升&emsp;&emsp;只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。函数表达式也不会被提升。&emsp;&emsp;每个作用域都会进行提升操作。 &emsp;&emsp;函数声明会提升&emsp;&emsp; &emsp;&emsp;函数表达式不会提升&emsp;&emsp;&emsp;&emsp;即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。&emsp;&emsp; &emsp;&emsp;函数优先&emsp;&emsp;函数声明和变量声明都会被提升，但是是函数首先被提升，然后才是变量。&emsp;&emsp;&emsp;&emsp;函数提升后，var foo是重复的声明，var foo会被忽略掉。 五、闭包&emsp;&emsp;当函数可以记住并访问所在的词法作用域，即使函数是在当前作用域之外执行，这时就产生了闭包。&emsp;&emsp;当一个函数返回它内部的一个函数时，就产生了闭包。如：&emsp;&emsp;&emsp;&emsp;Js特殊之处：可以在函数内部读取全局变量，但是不能再函数外部读取函数内部的局部变量。由于种种原因，我们需要在函数外面获取函数内部的局部变量，通过闭包的方法可以实现。即在函数内部在定义一个函数。&emsp;&emsp;闭包就是能访问另一个函数作用域中的变量的函数。创建闭包的方式，就是在一个函数内部创建另一个函数。本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 &emsp;&emsp;闭包的优点&emsp;&emsp;1、可以在函数外部读取函数内部的变量。&emsp;&emsp;2、可以将变量保存在内存中，避免使用全局对象。&emsp;&emsp;3、封装对象的私有属性和方法。&emsp;&emsp;4、在循环中使用。 &emsp;&emsp;闭包的缺点&emsp;&emsp;1、由于闭包都保存在内存中，使得内存消耗很大，不能滥用闭包。&emsp;&emsp;2、由于回收机制问题，可能导致内存泄露。解决办法，程序退出前，将不用的变量设置为null。&emsp;&emsp;3、增加了代码的复杂度，给维护和调试带来了不变。 【参考文章】1、了不起的javascript2、深入理解javascript作用域系列第二篇——词法作用域和动态作用域3、JavaScript的作用域和块级作用域概念理解","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"操作符","date":"2017-08-09T01:20:02.000Z","path":"2017/08/09/操作符/","text":"相等（==）操作符&emsp;&emsp;相等操作符的最终结果是将其他非数值类型转化为数值类型。相等操作符转换规则如下：&emsp;&emsp;&emsp;&emsp;左右两边类型相等：&emsp;&emsp;1、NaN != NaN &emsp;&emsp; -0 == +0&emsp;&emsp;2、两边都是对象比较的是地址&emsp;&emsp;左右两边类型不相等：&emsp;&emsp;1、undefined == null&emsp;&emsp;2、有 null/undefined 参与的 == 运算是不进行隐式转换。&emsp;&emsp;&emsp;&emsp;0 == null; // false&emsp;&emsp;&emsp;&emsp;null == false; // false&emsp;&emsp;&emsp;&emsp;”undefined” == undefined; // false&emsp;&emsp;3、一个是number，一个是string，string将调用toNumber()转换为number&emsp;&emsp;4、一个是boolean，一个是number，boolean将调用toNumber()转换为number&emsp;&emsp;5、一个是boolean，一个是string，boolean和String将调用toNumber()转换为number&emsp;&emsp;6、一个是object，另一个是其他（string/number),object将调用toPrimitive() &emsp;&emsp;toNumber方法即Number转换规则：&emsp;&emsp; &emsp;&emsp;toPrimitive方法如下：&emsp;&emsp;&emsp;&emsp;原始值指的是[‘Null’,’Undefined’,’String’,’Boolean’,’Number’]五种基本数据类型之一 &emsp;&emsp;valueOf返回值：&emsp;&emsp;注意：Number、Boolean、String有属于自身的原型valueOf方法，不是直接从Object.prototype上继承下来，归纳如下：&emsp;&emsp; &emsp;&emsp;toString返回值：&emsp;&emsp; &emsp;&emsp;==总结&emsp;&emsp; 一元加操作符&emsp;&emsp;var num = 25；&emsp;&emsp;num = +num;&emsp;&emsp;改操作符会像Number（）函数一样对非数值类型进行转换。 布尔操作符&emsp;&emsp;操作符转换规则：&emsp;&emsp; &emsp;&emsp;! 取反&emsp;&emsp;!x 将表达式x转换成布尔值（Boolean），之后在将结果取反。&emsp;&emsp;!!x 则表示取 x 表达式的运行结果的布尔值。&emsp;&emsp;&emsp;&emsp;var obj = {};&emsp;&emsp;&emsp;&emsp;var a = !obj // false;&emsp;&emsp;&emsp;&emsp;var a = !!obj // true; &emsp;&emsp;&amp;&amp; 逻辑与&emsp;&emsp;x &amp;&amp; y 如果 x 表达式的运行结果转换成 Boolean 值为 false 则不运行表达式 y 而直接返回 x 表达式的运行结果。相反，如果 x 表达式的运行结果转换成 Boolean 值为 true 则运行表达式 y 并返回 y 表达式的运行结果。 &emsp;&emsp;|| 逻辑或&emsp;&emsp;x || y 如果 x 表达式的运行结果转换为 Boolean 值为 true，则不运行 表达式 y 而直接返回表达式 x 的运算结果。（与 &amp;&amp; 方式相反） 【参考文章】1、从 []==![] 为 true 来剖析 JavaScript 各种蛋疼的类型转换2、toString 方法 (Object) (JavaScript)3、valueOf 方法 (Object) (JavaScript)4、表达式与运算符","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript基础----引用类型","date":"2017-08-07T01:20:15.000Z","path":"2017/08/07/javascript基础---引用类型/","text":"&emsp;&emsp;javascript 类型系统可以分为标准类型和对象类型，进一步标准类型又可以分为原始类型和引用类型，而对象类型又可以分为内置对象类型、普通对象类型、自定义对象类型。&emsp;&emsp; 标准内置对象构造器对象ObjectBooleanStringNumberFunctionArrayRegExpDateError其他对象 MathJSON全局对象 类型识别&emsp;&emsp;typeof&emsp;&emsp;Object.prototype.toString&emsp;&emsp;constructor&emsp;&emsp;instanceof &emsp;&emsp;typeof：&emsp;&emsp;可以是标准类型（Null 除外）&emsp;&emsp;不可识别具体的对象类型（Function 除外） &emsp;&emsp;Object.prototype.toString：&emsp;&emsp;可以识别标准类型&emsp;&emsp;可是识别标准类型及内置对象类型（例如，Object, Date, Array）&emsp;&emsp;不能识别自定义对象类型 &emsp;&emsp;constructor：&emsp;&emsp;可以识别标准类型（Undefined/Null 除外）&emsp;&emsp;可识别内置对象类型&emsp;&emsp;可识别自定义对象类型 &emsp;&emsp;instanceof：&emsp;&emsp;不可判别原始类型&emsp;&emsp;可判别内置对象类型&emsp;&emsp;可判别自定义对象类型&emsp;&emsp;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript基础---基本数据类型","date":"2017-08-04T14:11:50.000Z","path":"2017/08/04/javascript基础---基本数据类型/","text":"一、Javascript简介&emsp;&emsp; 在上个世纪1995年，Netscape公司凭借其Navigator浏览器成为第一代互联网公司。之后，Netscape公司希望能在静态HTML页面上添加一些动态效果，于是Brendan Eich在两周之内设计出了JavaScript语言。由于当时java很火，Netscape公司希望借java热风推广，便取名为javascript。&emsp;&emsp; 之后，微软模仿javascript开发了Jscript，此时，相当于有了两个JavaScript版本。为了让Javascript成为国际标准，几个公司联合ECMA组织制订了Javascript语言的标准，被称为ECMAScript标准。&emsp;&emsp; ECMA就是对标准规定的各个方面内容的语言的描述，可以理解为ECMA仅仅是一个描述，定义了脚本语言的所有属性、方法和对象。其他的语言可以实现ECMAScript，来作为功能的基准，javascript就是这样。&emsp;&emsp; web浏览器只是ECMAScript实现可能的宿舍环境之一，宿主环境不仅提供基本的ECMAScript实现，同时也会提供语言的扩展。可以理解为每个浏览器都有自己的ECMAScript接口，然后这个实现又被扩展，包含了BOM和DOM以及其他扩展。&emsp;&emsp;一个完整的javascript实现应该由下列三个不同的部分组成：&emsp;&emsp;● ECMAScript（核心） ECMAScript描述了该语言的语法和基本对象；&emsp;&emsp;● DOM（文档对象模型）DOM 描述了处理网页内容的方法和接口；&emsp;&emsp;● BOM（浏览器对象模型）BOM描述了与浏览器进行交互的方法和接口。 二、Javascript数据类型&emsp;&emsp;ECMAScript中有6种简单数据结构（基本数据类型）：Undefined、Null、Boolean、Number、String、Symbol。还有一种复杂结构类型（引用类型）Object。&emsp;&emsp;基本数据类型保存在内存的栈区，复制变量时会创建其值的一个副本。基本数据类型可以使用typeof区分。&emsp;&emsp;引用类型的存储是由内存的栈区和堆区共同完成，引用类型的值是对象,保存在堆内存中，栈区内存保存变量标识符和指向堆内存中该对象的指针，也就是该对象在堆内存的地址。 1、Undefined类型&emsp;&emsp;使用var声明但是未初始化的变量其值为undefined。使用未声明的变量会报错。如：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;但是，对未初始化的变量执行typeof操作符会返回undefined值，对未声明的变量执行typeof操作符也会返回undefined。&emsp;&emsp;&emsp;&emsp; 2、Null类型&emsp;&emsp;如果定义的变量将来准备用于保存变量，那么最好将该变量初始化为null。 &emsp;&emsp;null和undefined的区别&emsp;&emsp;undefined派生自null，用相等操作符(==)它们是相等的。&emsp;&emsp;&emsp;&emsp;在if语句中，null和undefined都会被转换为false。但是，它们都不等于0，false或””&emsp;&emsp;&emsp;&emsp;null转为数值时值为0,undefined转为数值时值为NaN.&emsp;&emsp;typeof null 返回object, typeof undefined 返回undefined.&emsp;&emsp;&emsp;&emsp;undefined表示“不存在的值”，应用场景:&emsp;&emsp;1、变量声明了，但是没有赋值，会有一个undefined的默认值；&emsp;&emsp;2、调用函数时，函数没有赋值的参数，默认为undefined；&emsp;&emsp;3、试图访问不存在的对象属性时，会返回undefined值；&emsp;&emsp;4、函数没有返回值，默认返回undefined。&emsp;&emsp;null表示“没有对象”，应用场景：&emsp;&emsp;1、作为函数的参数，表示该函数的参数不是对象；&emsp;&emsp;2、作为原型对象链的终点；&emsp;&emsp;3、通过分配null值，有效的清除引用，并假设对象没有引用其他代码，指定垃圾回收，确保回收内存。&emsp;&emsp;在ES5中，Object.prototype.toString()方法，已经成为实际的类型检验标准。 3、Boolean类型&emsp;&emsp;Boolean类型有两个值:true和false。&emsp;&emsp;要将一个值转换为Boolean值，可以调用转型函数Boolean()。各种数据类型极其对应的转换规则：&emsp;&emsp; 4、Number类型&emsp;&emsp;数值字面量可以是十进制整数，八进制整数，十六进制整数。其中八进制字面量的第一位必须是零（0），数字序列为（0-7）；十六进制字面量的前两位必须是0x，数字序列（0-9及A-F），字母可大写可小写，超出范围报错。 &emsp;&emsp;（1）数值范围&emsp;&emsp;Number.MAX_VALUE 最大数值&emsp;&emsp;Number.MAX_VALUE 最小数值，代表的并不是负最小，而是最接近0的一个数&emsp;&emsp;-Number.MAX_VALUE 负最小 &emsp;&emsp;（2）NaN&emsp;&emsp;任何数除以0都会返回NaN，其次，NaN与任何值都不相等，包括NaN本身。 &emsp;&emsp;（3）数值转换&emsp;&emsp;有3个函数可以把非数值转换为数组，Number()、parseInt()、parseFloat()。&emsp;&emsp;Number()可以用于任何数据类型，而另外两个专门用于把字符串转换为数组。 &emsp;&emsp;Number函数转换规则&emsp;&emsp;如果是Boolean值，true和false将分别被转换为1和0。&emsp;&emsp;如果是数字值，只是简单的传入和返回。&emsp;&emsp;如果是undefined，返回NaN。&emsp;&emsp;如果是null，返回0。&emsp;&emsp;如果是字符串，&emsp;&emsp;&emsp;&emsp;若只包含数字，则将其转化为十进制数值。如”1”-&gt;1，”123”-&gt;123，而”011”-&gt;11。&emsp;&emsp;&emsp;&emsp;如果字符串包含有效的十六进制格式，如”0xf”，则将其转化为相同大小的十进制。&emsp;&emsp;&emsp;&emsp;如果字符串包含有效的浮点格式，如”1.1”，则将其转化为对应的浮点数值。&emsp;&emsp;&emsp;&emsp;如果字符串是空的或者只包含空格字符串，则将其转化为0。&emsp;&emsp;如果是对象，则调用对象的valueOf()方法，然后按照前面的规则转换。如果转换的结果是NaN，则调用对象的toString()方法，然后按照前面的规则转换。 &emsp;&emsp;parseInt函数转换规则—针对字符串&emsp;&emsp;parseInt（）函数在转换字符串时，会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt（）就会返回NaN，即parseInt会将空的字符串转化为NaN。&emsp;&emsp;parseInt可以指定基数，如：&emsp;&emsp;var num1 = parseInt(“10”,2);&emsp;&emsp;var num1 = parseInt(“10”,10);&emsp;&emsp;var num1 = parseInt(“10”,16); &emsp;&emsp;parseFloat函数转换规则—针对字符串&emsp;&emsp;parseFloat（）函数与parseInt类似，解析遇到一个无效的浮点数字字符为止。也就是说，第一个小数点有效，第二个小数点无效。&emsp;&emsp;注意：parseFloat在解析十六进制的字符串时，会始终将其转换为0。parseFloat只解析十进制，没有第二个参数（基数）的用法。 5、String类型&emsp;&emsp;字符串可以由单引号’’或者双引号””表示。字符串是不可变的，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，如：&emsp;&emsp;var lang = “Java”;&emsp;&emsp;lang = lang + “Script”;&emsp;&emsp;首先创建一个能容纳10个字符的新字符串，然后在这个字符串中填充”Java”和”Script”,最后是销毁原来的字符串”Java”和字符串”Script”。 &emsp;&emsp;转换为字符串&emsp;&emsp;第一种是几乎每个值都有的toString()方法，但null和undefined值没有这个方法。&emsp;&emsp;第二种：在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String(),这个函数能将任何类型的值转换为字符串。转换规则如下：&emsp;&emsp;如果有toString()方法，则调用并返回相应的结果；&emsp;&emsp;如果值是null，则返回”null’；&emsp;&emsp;如果值是undefined，则返回’undefined’； 6、Symbol类型&emsp;&emsp;symbol是程序创建并且可以用作属性键的值，并且它能避免命名冲突的风险。&emsp;&emsp;var mySymbol = Symbol();&emsp;&emsp;obj[mySymbol] = “ok!”; // 保证不会冲突&emsp;&emsp;console.log(obj[mySymbol]); // ok!&emsp;&emsp;symbol被创建后就不可变更，你不能为它设置属性（在严格模式下尝试设置属性会得到TypeError的错误）。他们可以用作属性名称，这些性质与字符串类似。&emsp;&emsp;另一方面，每一个symbol都独一无二，不与其它symbol等同，即使二者有相同的描述也不相等；你可以轻松地创建一个新的symbol。这些性质与对象类似。 6、Object类型对象其实就是一组数据和功能的集合。引用类型下一篇文章总结。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"认识vue.js","date":"2017-07-28T07:45:17.000Z","path":"2017/07/28/认识vue.js/","text":"我们首先了解一下MVX模式MVX模式：MVC、MVP、MVVM MVCMVC一般分为Model（模型）、View（视图）和Controller（控制器）。 View一般通过Controller来和View进行联系。Controller是View和Model的协调者。基本联系都是单向的。1.View传送指令到Controller2.Controll接收指令处理后，要求Model改变状态3.Model将新的数据传送给View。 MVPMVP一般分为Model（模型）、View（视图）和Presenter。Presenter把View和Model进行了分离，而且，Presenter与具体的View没有直接联系，是通过定义好的接口进行联系的。 MVVMMVVM分为Model（模型）、View（视图）和ViewModel。View的变化会自动更新到ViewModel，viewModel的变化也会同步到View上。MVVM采用双向绑定（data-binding）","tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://yoursite.com/tags/vue-js/"},{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"}]},{"title":"Hello World","date":"2017-02-27T03:08:12.227Z","path":"2017/02/27/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]